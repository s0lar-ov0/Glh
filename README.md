# C 程序分析：寻找二维数组中连续的 1

## 代码目的：
本程序的目的是在给定一个二维数组（最多有 10 行 100 列）后，逐行寻找其中最长的连续 1，并输出该段 1 的起始和结束位置。如果某行没有连续的 1，输出 `-1 -1`。

## 代码分析

### 1. 初始化和输入
```c
int m, n, a[10][100] = {0};  // 声明二维数组，最多10行100列
scanf("%d %d", &m, &n);  // 输入行数m和列数n
```
- `m` 和 `n` 是二维数组的行数和列数，最大可以分别为 10 和 100。
- `a[10][100]` 是一个二维数组，初始值为 0，表示数组的元素初始化为零。
- 通过 `scanf` 输入二维数组的行数 `m` 和列数 `n`。

### 2. 输入二维数组的每个元素
```c
for(int i = 0; i < m; i++){
    for(int j = 0; j < n; j++){
        scanf("%d", &a[i][j]);
    }
}
```
- 使用嵌套循环遍历二维数组 `a`，逐个输入每个元素的值。输入的元素可以是 0 或 1。

### 3. 逐行处理数组
对于每一行，程序尝试找到连续的 1，并计算其长度，最终输出最长连续 1 的起始和结束位置。

#### 3.1 初始化辅助数组
```c
int sum = 0, b[100] = {0}, f[100] = {0}, c = 0, q = 0;
int currentstart = -1;
```
- `sum`: 用来记录当前连续 1 的长度。
- `b[100]`: 用来存储每个连续段的长度。
- `f[100]`: 用来存储每个连续段的起始位置。
- `c`: 用来记录当前连续段的数量。
- `q`: 未使用，可能是冗余变量。
- `currentstart`: 标志当前是否已经找到了连续 1 的起始位置，初始化为 -1。

#### 3.2 遍历每行的元素
```c
for(int j = 0; j < n; j++){
    if(a[i][j] == 1){  // 当前元素是1，表示连续部分的开始
        sum = sum + 1;  // 连续1的长度加1
        if(currentstart == -1){  // 如果是当前行的第一个1
            f[c] = j;  // 记录起始位置
        }
        currentstart = 0;
        
        // 如果当前元素后面是0，表示连续段结束
        if(j == n - 1 || a[i][j + 1] == 0){  // j == n - 1 处理最后一列是1的情况
            b[c] = sum;  // 记录当前连续1的长度
            c = c + 1;  // 移动到下一个段
            sum = 0;  // 重置当前段长度
            currentstart = -1;  // 重置起始位置
        }
    }
}
```
- `if(a[i][j] == 1)`: 如果当前元素为 1，则开始计算连续 1 的长度。
- `sum = sum + 1`: 增加当前连续 1 的长度。
- `if(currentstart == -1)`: 如果当前是连续 1 的起始位置（即该行的第一个 1），记录下该位置。
- `if(j == n - 1 || a[i][j + 1] == 0)`: 如果当前元素后面是 0 或者当前元素是最后一列，说明当前段的连续 1 结束。此时将当前连续段的长度存入数组 `b`，并记录该段的起始位置到数组 `f` 中。
- 每次连续 1 段结束后，重置 `sum` 和 `currentstart` 为初始值。

#### 3.3 处理没有连续 1 的情况
```c
if(c == 0){
    printf("-1 -1\n");
}
```
- 如果 `c` 为 0，说明该行没有连续的 1，直接输出 `-1 -1`。

### 4. 找到最大长度的连续 1 并输出
```c
int max = b[0], qishi = f[0];
for(int k = 1; k < c; k++){
    if(b[k] > max){
        max = b[k];
        qishi = f[k];
    }
}
printf("%d %d\n", qishi, qishi + max - 1);
```
- `max`: 存储最大连续 1 的长度。
- `qishi`: 存储最大连续 1 的起始位置。
- 遍历 `b` 数组，找到最大值，并记录对应的起始位置 `qishi`。
- 最后输出最长连续 1 的起始和结束位置，结束位置为 `qishi + max - 1`。

### 5. 程序结束
```c
return 0;
```
- 程序正常结束，返回 0。

## 例子

假设输入如下：

```
3 5
1 0 1 1 0
1 1 1 0 1
0 1 0 1 1
```

**输出**：
```
2 3
0 2
3 4
```

### 解释：
- 第一行有两个连续 1 的段，最长的是从索引 2 到 3。
- 第二行有一个连续的 1，最长的是从索引 0 到 2。
- 第三行有两个连续 1 的段，最长的是从索引 3 到 4。

## 代码总结
该程序通过遍历二维数组的每一行，寻找并记录每一行中连续 1 的段及其长度，然后找出每行中最长的连续 1 段的起始和结束位置。如果没有找到任何连续的 1，则输出 `-1 -1`。